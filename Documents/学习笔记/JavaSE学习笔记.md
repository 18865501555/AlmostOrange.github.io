## API

- 应用编程接口
  - 现成的程序组件
- Java核心API
  - Java中最常见的程序组件
    - 字符串
    - 包装类
    - IO
    - 网络
    - 线程
    - ……

---

## String字符串

- Java中用于表示输入输出文字的API

  - 如Abc就是一个字符串
  - 任何ABC都是字符串
  - 字符串类型提供了很多字符串操作API，这些API可以方便程序编写，提高开发效率
- 字符串都是对象
  - 如果定义了与JavaAPI同名的类，则在后续编码中，必须不能省略（加上）Java的包名，如果：java.lang.String使用非常不方便！
    - 建议：不要将类名定义成与Java API类名同名！
  

### 字符串特点

- 字符串对象内部封装的是一个固定不变的字符数组，称为字符串对象不可以改变，简称"不变对象"
  - 可以根据序号获取字符串中的字符
  - 可以利用length()检查字符的个数
- 任何字符串API方法或者字符串连接操作都不会改变字符串对象
- 字符串字面量是字符串对象
- Java为了性能，提供字符串常量池

### 字符串对象不可改变

- "字符串对象"不可改变
- 字符串引用变量可以改变
- Java中字符串发生改变时候，都会创建新的字符串对象

### 字符串常量池

- Java为了优化字符串性能，而设计字符串常量池
- 利用常量池"复用"字符串字面量、常量、字面量运算结果
- 字符串在操作期间，会大量产生新字符串，如果全部复用，势必会造成内存不够
- 如果不进行字符串对象复用，又会因为反复创建字符串造成大量性能开销
- java设计了一个折中策略
  - 静态字符串进行重复使用，第一次使用时创建
  - 动态生成的字符串，一次使用，使用后，不被引用时销毁
- 静态字符串创建后存储到常量池，如果出现复用的时候，重复使用同一个字符串

### 将字符串转换为大写字符串

- toUpperCase() 将字符串每个字符，转换为对应的大写
- toUpperCase() JAVA提供的API方法。
- 可以在字符串“字面量”上直接调用API方法

```java
String s = "Hello World";
String s1 = s.toUpperCase();
System.out.println(s1);//HELLO WORLD
String str = "Hello World!".toUpperCase();
```

### 将字符串转换为小写字符串

- toLowerCase() 将字符串每个字符，转换为对应的小写
- toLowerCase() JAVA提供的API方法。
- 可以在字符串“字面量”上直接调用API方法

```java
String s = "Hello World";
String s1 = s.toLowerCase();
System.out.println(s1);//hello world
String str = "Hello World!".toLowerCase();
```

### 字符串中的字符

- 字符串封装了字符数组，也就是字符串由一个一个字符组成
- 与字符数组类似，字符串中每个字符也具有唯一的下标序号
- charAt()方法根据序号获得字符串中的一个字符
- length()方法获得当前字符串中字符的个数

### 检查是否为空字符串

- 没有内容的字符串，称为空字符串
- isEmpty()用于检查字符串是否为空字符串，如果是空的就返回true

### 判断两个字符串相等

- ==用于比较字符串时，用于检查是否是同一个字符串对象
  - 如果是同一个对象，则true
  - 不引用同一个对象，则false
- ==不能用来比较字符串内容是否一样
- Java提供了API方法equals(相等)，用来比较两个字符串是否相等
- equals底层就是将两个字符串的每个字符逐一进行对比，判断是否相等

### 查找字符串中字符(字符串)的位置

- indexOf检索一个字符在字符串中出现的位置(索引位置)

### 从后向前查找字符(字符串)的位置

- lastIndexOf

- 例如从URL截取文件名

  - `http://tomcat/demo.css`文件名`demo.css`

  - 如何得到文件名的位置，从后向前查找"/"的位置，找到以后“/”加1就是文件名的起始位置

  - 使用substring(index), index是文件名第一个字符的起始位置

    ```java
    String url = "http://tomcat/demo.css";
    int index = url.lastIndexOf("/");
    String file = url.substring(index+1);
    System.out.println(file); 
    ```

### 去除字符串两端的空白

- str.trim() 去除字符串前后的空白
- 空白包括，Unicode编号小于等于\U0020的字符，如 空格，回车、换行等
- trim() 经常用于去除用户意外输入的空白字符 

### 子字符串

- 获取子字符串
  - 截取一个字符串中的一部分
- 从原始字符串str中截取一部分，返回时候包含开始位置，不包含结束位置
  - beginIndex开始位置
  - endIndex结束位置
- substring方法可以按照长度截取字符串
  - substring(开始位置,开始位置+截取长度);
- substring提供了重载的方法
  - 从指定位置开始，截取到字符串末尾

---

## StringBuilder

- String:字符串
- Builder:构建器
- Java提供的动态字符串API，用于动态处理拼接字符，作为String的操作工具，用于生产String对象
- 因为String对象不可以改变，String在操作时候，会利用复制(数组复制)来创建新字符串对象，复制数组是非常耗时的操作。String的动态处理性能不好
  - toLowerCase() trim()连接，都会利用数组复制产生新的对象
- java提供了StringBuilder,是可变字符串对象，其内部的字符数组可以改变，StringBuilder在更改时候，可以减少char数组复制
- StringBuilder相对于String具有更好性能
- 操作字符串时候，尽量使用StringBuilder，处理结束以后，生成String

### 使用StringBuilder API

- StringBuilder提供的方法，内部封装了可以改变的char数组
- StringBuilder的API可以更新其内部char数组内容
- StringBuilder在其内部char数组容量不足时会自动扩容char数组
  - 新容量一般为1倍+2

### StringBuilder动态操作字符串

- append(内容)
  - 追加字符内容
- insert(位置,内容)
  - 在指定位置插入内容，插入时候原有内容会向后移动
- delete(开始位置,结束位置)
  - 将指定范围内的字符删除，包含开始位置，不包含结束位置
- append insert delete方法返回值就是当前对象本身
- 所以适合连续方法调用，其好处就是可以减少编码量，提高编程效率
- 连续使用`.`调用方法的编码风格称为:函数式编程
- buf.capacity()
  - 检查数组容量大小

### String与StringBuilder使用建议

- 一般情况下，输出文字信息都使用String
- 需要大量修改字符串，就使用StringBuilder，性能好
- StringBuilder处理结束以后，转换为String
- String的连接底层就是利用StringBuilder实现的

---

## 正则表达式

- 简称正则

### 什么是正则表达式

- 正则本身是包含正则语法字符串
- 正则用于约定目标字符串的规则
- 几乎所有的编程语言都支持正则，语法基本一样

### 正则表达式核心用途

- 匹配目标字符串的规则

### 常见字符串规则

- 密码规则
  - 包含大写、小写、数字和特殊符号,至少3个
  - 用户名规则
  - 电话号码规则
  - Java代码规则
  - ……
- 我们软件中也是需要检验一个字符串是否符合特定的规则
- 正则表达式就是用于检验字符串规则的语法

### 字符集

- 约定一个字符的可选择范围
- Hello[abc]
  - 连续6个字符，前五个必须是Hello，最后一个是 a b c 3个之一
- Hello[a-z]
  - 连续6个字符，前五个必须是Hello，最后一个是 a到z 之一
- Hello[a-zA-Z]
  - 连续6个字符，前五个必须是Hello，最后一个是 a到z 或 A到Z 之一

### 缩写字符集

- [0-9]
  - 等价于 \d一个字符，字符是0到9的某一个 
  - 例子
    - Hello\d 前五个必须是Hello，最后一个是 0到9 之一
    - 正则表达式 Hello\d 写成Java以后： reg="Hello\\d";
- [0-9a-zA-Z_]
  - 等价 \w  单词字符
  - 例子
    - Hello\w 前五个必须是Hello，最后一个是 0到9 a-z A-Z _ 之一
    - . 英文句号  表示匹配任何一个字符 
  - 例子
    - Hello. 前五个必须是Hello，最后一个是 任意一个字符
    - \s 匹配空白 表示一个 空格 tab 回车 换行 等
  - 例子
    - Hello\s 前五个必须是Hello，最后一个是 任意一个空白字符
  - 注意大小写
    - \D  表示非数字，除了数字以外的其他一个字符
    - \S  表示非空白，除了空白以外的其他一个字符
    - \W  表示非单词字符，除了单词字符以外的其他一个字符
  - 注意
    - Java代码中，字符里面的斜线`\` 需要转义为 `\\`
    - 字符集只匹配一个字符，如果匹配多个字符，需要重复书写或者使用“数量词”

### 数量词

- 利用数量词可以约束左侧字符出现的个数

  - H{3}
    - {3}用于约定左侧字符H必须出现3次
  - \d{3}
    - {3}用于约定左侧字符\d必须出现3次
  - H{8,10}  
    - {8,10} 用于约定左侧字符H必须出现8次到10次
  - \d{8,10} 
    - {8,10} 用于约定左侧字符\d必须出现8次到10次
  - H{3,}    
    - {3,} 用于约定左侧字符H必须出现3次以上
  - H{0,4}   
    - {0,4}  用于约定左侧字符H必须出现0到4次

- 简写数量词

  - `+`{1,}  左侧字符出现1个以上
  - `?`{0,1} 左侧字符出现1次或没有

  *  `*`{0,}  左侧字符出现0个以上

### 分组

- 规则：将一个字符序列作为一个整体组进行管理

### 匹配特殊字符

- 如何匹配 (^_^) 就遇到了特殊符号：（ ) ^ 

- 还有很多特殊符号： \ + ？ * [ ] ,  . 等 

- 使用转义字符匹配特殊符号 "\特殊符号"

```
\(\^_\^\)   用来匹配 (^_^) 
(\(\^_\^\)){3} 用来匹配 (^_^)(^_^)(^_^)
```

- 案例：
  - 匹配一个手机号码，要求能够处理中国区号
    - +86 13612334334 
    - 0086 13612334334 

```
电话号码规则：(\+86|0086)?\s?\d{11}
email: [a-zA-Z0-9_\.]+@[a-zA-Z0-9-]+[\.a-zA-Z]+
```

### 正则API

- matches() 检查正则是否全部匹配
- split() 字符串切分 
  - 根据正则将字符串劈开(split)
  - 匹配到劈开位置，劈开时候匹配字符去除
  - 将剩余部分存储到数组
- replaceAll 替换
  - 将正则表达式匹配的字符串找到，替换为指定的字符串
  - replaceAll(正则, 被替换的参数)

---

## Object

- 对象、东西

- Object类是所有类的父类型，Sun公司设计，将所有子类都应该有的属性和方法定义到Object类型上，所有子类型都继承了这些方法。 

- Object类型上属性和方法所有子类型都有继承。 
  - 这些包括 toString equals 等

### toString()

- 用于返回对象的文字描述信息

- Object默认的toString()返回了：类名@散列值
  - 散列值，是一个随机序号，不要当做对象的内存地址
  - 这个返回值没有用途!

- java建议对这个方法进行重写，实现用户希望的结果
  - 开发工具提供自动重写功能，利用即可

- 很多Java提供的API等都会自动调用toString, 自动调用toString可以大大节省代码
  - 字符串连接时候会自动调用
  - println() 输出对象时候
  - 等 ... 
- 默认情况下子类继承了Object 的toString, 默认值无意义！
- toString() 方法经常默认被调用， 可以节省代码
- 字符串连接时候会自动调用 toString

- 注意
  - 程序输出了 “类名@散列值” 这样的丑陋结果， 一定是你忘记了重写对象的toString！ 

### equals

- Object 定义了用于比较对象相等的方法 equals

- Java中 == 不能用于比较两个对象的“属性值”是否相等

- Object提供的默认 equals， 其实现也是 == 比较，和==功能一样。无法使用！建议在子类中进行重写！

- 开发工具提供了自动重写 equals 方法。

- Java提供类，几乎都重写了 equals 和 toString，

---

## 包装类

- 面向对象
  - 一切皆对象，数据也应该是对象

- Java为了解决性能问题，保留基本类型，基本类型运算性能好, 基本类型不是对象

- Java设计包装类，利用包装类将基本类型包装成对象。

- 可以将基本类型包装为对象，作为对象使用， 使用方式在以后讲解！

- 8 个基本类型，对应的8个包装类型，都在java.lang包

- 数值类型包装类提供了相互类型转换的方法，相当于强制类型转换，和强制类型转换一样，会发生溢出，精度损失。

- 包装类提供了将“人类习惯文本信息”转换为基本类型的方法
- 包装类型提供将文字数据转换为对应数据类型的方法
  - 提供的数据不能超过正常范围

---

## File

- file 文件
  - 代表文件、文件夹，用于操作文件、文件夹。 

- Java提供API，可以用于对文件、文件进行操作：
  - 创建文件夹、文件夹改名、创建文件、文件改名、删除文件、删除文件夹

- file.getName() 获取当前文件夹、文件的名字
- Absolute 绝对 Path 路径，从根目录到当前目录的绝对位置信息

### 创建文件夹

- ./代表当前目录，当前项目文件夹
- File 提供了创建文件夹的方法 mkdir() 执行这个方法，就会在磁盘上创建一个文件夹
  - 如果文件夹不存在，就会创建文件夹，返回true
  - 如果文件夹已经存在，就不做任何操作，返回false，表示没有创建
  - 如果磁盘有问题，有故障，会出现“异常” 出现红字
- mkdirs() 创建系列文件夹，可快速创建一系列文件夹

### 删除文件或者文件夹

- delete()
  - 文件就直接删除，返回true
  - 空文件夹直接删除，返回true
  - 非空文件夹不删除，返回false， 为了安全，避免意外删除

### 创建空文件

- createNewFile() 调用方法会创建文件
  - 如果返回true表示文件创建成功
  - 如果返回false表示文件创建失败
  - 在一个文件夹中不能同时存在相同的文件、文件夹，这里的同名是文件名可扩展名都相同
  - 文件夹和文件的名字都可以包括主文件名和扩展名

### 检查文件、文件夹是否存在

- exists() 检查当前file对象，对应的磁盘文件、文件夹是否已经存在
  - 如果存在就返回true
  - 如果不存在就返回false

### 检查是文件还是文件夹的方法

- File 提供了检查是文件还是文件夹的方法
- isFile() 检查是否是文件
  - 如果是文件就返回true
- isDirectory() 检查是否文件夹
  - 如果是文件夹就是true
- 如果根本不存在的文件
  - 这个两个方法返回值都是false

### File 提供的API可以检查相关的属性

- 检查文件的属性
  - 文件长度、文件名称、文件的父目录、是否可以读取
- getCanonicalFile() 
  - 获取规范名称

### 文件改名

- rename 改名 
- 原文件.renameTo(新文件) 
  - 返回true，表示成功

### 列文件夹的内容（列目录）

- listFiles() 获取文件夹file的全部内容
  - 内容就是子文件夹和文件。
- 在文件上调用 listFiles 会得到 null！

### 有条件的列目录内容

- 是一个重载的listFiles
- 例子
  - 将首字母为 “S”文件列出来
  - 过滤条件 = name.startsWith("S");
  - file.listFiles(过滤条件);
- 创建过滤条件: file.getName().startsWith("I")

---