### 封装包含

- 类
  - 封装的是对象的属性和行为
- 方法
  - 封装的是具体的业务逻辑功能实现
- 访问控制修饰符
  - 封装的是具体的访问权限

### 类

- 现实生活中是由很多很多的对象组成的，基于对象抽出类

#### 什么是类

- 模子、类型/类别，代表一类个体
- 类是对象的模板，对象是类的具体的实例

#### 类中包含

- 成员变量
  - 对象所共有的属性/特征(数据)
- 方法
  - 对象所共有的行为(动作)

#### 如何创建类？如何创建对象？如何访问成员？

- 创建类: class 类名{ 成员变量、方法 }

- 创建对象: 类名 引用类型变量(引用) = new 类名();

- 访问成员: 引用.成员变量名 = 值;引用.方法名();

#### package

- 作用: 避免类名的冲突

- 类的全称: 包名.类名 包名有层次结构

- 同包中的类名不能同名，不同包中的类可以同名

- 建议: 包名所有字母都小写

#### import

- 同包中的类可以直接访问

- 不同包中的类不能直接访问，若想访问:
  - 先import声明类，再访问类，建议
  - 类的全程，太繁琐，不建议

### 访问控制修饰符

- 类的访问修饰符只能是public或默认的

- 类中成员的访问修饰符以下4种都可以

#### public

- 公开的，任何类
  - 行为(方法)公开化(public)

#### private

- 私有的，本类
  - 数据(成员变量)私有化(private)

#### protected

- 受保护的，本类、派生类、同包类
  - 超类的成员变量设计为受保护的

#### 默认的

- 什么也不写，本类、同包类
  - java不建议默认权限

### 成员变量

- 实例变量: 
  - 没有static修饰，属于对象的，存储在堆中，有几个对象就有几份，通过对象名点来访问
- 静态变量: 
  - 由static修饰，属于类的，存储在方法区中，只有一份，通过类名点来访问

### static

- 静态的

#### 静态变量

- 由static修饰
- 属于类，存储在方法区中，只有一份
- 常常通过类名点来访问
- 何时用: 
  - 所有对象所共享的数据(图片、音频、视频等)

#### 静态方法

- 由static修饰

- 属于类，存储在方法区中，只有一份

- 常常通过类名点来访问

- 静态方法没有隐式的this传递，所以静态方法中不能直接访问实例成员
- 何时用:
  -  方法的操作与对象无关

#### 静态块

- 由static修饰
- 属于类，在类被加载期间自动执行，因每个类只被加载一次，所以静态块只执行一次--发生的时期最早
- 何时用: 
  - 加载/初始化静态资源(图片、音频、视频等)

### final

- 最终的

#### 修饰变量

- 变量不能被改变

#### 修饰方法

- 方法不能被重写

#### 修饰类

- 类不能被继承

### static final常量

- 应用率高
- 必须声明同时初始化
- 通过类名点来访问，不能被改变
- 建议: 常量名所有字母都大写，多个单词用_分隔
- 编译器在编译时将常量直接替换为具体的值，效率高
- 何时用: 数据永远不变，并且经常使用

### 成员内部类

- 成员内部类: 应用率低
- 类中套类
  - 外面的类称为Outer外部类
  - 里面的称为Inner内部类
- 内部类通常只服务于外部类，对外不具备可见性
- 内部类对象通常只在外部类中创建
- 内部类中可以直接访问外部类的成员(包括私有的)
- 内部类中有个隐式的引用指向了创建它的外部类对象
- eg: 外部类名.this.

### 匿名内部类

- 匿名内部类: 简化代码
- 若想创建一个类(派生类)的对象，并且对象只被创建一次，此时该类不必命名，称为匿名内部类 
- 若想访问外面的变量，该变量必须是final的(JDK1.7(包括)以前必须的)
- 内部类有独立的.class吗？
  - 有