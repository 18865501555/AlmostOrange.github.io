## Java开发环境

### Java编译运行过程

- 编译期
  - `Java`源文件，经过编译，生成`.class`字节码文件
  - 重载发生在此时期(不生成对象，所以看参数/引用类型)
- 运行期
  - `JVM`加载`.class`并运行`.class`
- 重写发生在此时期(已经有对象了，所有看对象类型)
  
- 特点
  - 跨平台、一次编译到处运行

### JVM、JRE、JDK名词解释

- JVM
  - `Java`虚拟机
  - 加载`.class`并运行`.class`
- JRE
  - 除了包含JVM以外，还包含了运行Java程序所必须的环境
  - JRE=JVM+Java系统类库
- JDK
  - 除了包含JRE以外，还包含了开发Java程序所必须的命令工具
  - JDK=JRE+编译、运行等命令工具
- 说明
  - 运行Java程序的最小环境为JRE
  - 开发Java程序的最小环境为JDK
  - JDK= JVM+java系统类库+编译、运行等命令工具
  - 配置环境变量
    - JAVA_HOME:指向jdk的安装路径
    - CLASSPATH:表示类的搜索路径，一般简写为`.`(当前目录)
    - PATH:指向jdk下的bin目录

### 注释

- 解释性文本
  - 单行注释：`//`
  - 多行注释：`/* */`
  - 文档注释：`/** */`

---

## 变量

- 存数的，代词，指代的就是它所存的那个数

### 声明

- 相当于开户
- int a;声明一个整型变量，名为a
- int b,c,d;声明三个整型的变量，名为b,c,d

### 初始化

- 第一次赋值
- int a = 250;声明政协变量a并赋值为250

### 使用

- 对变量的使用就是对它所存的那个数的使用

  ```java
  int a =5;
  int b = a+10;//取出a的值5，加10后，再赋值给整形变量b
  System.out.println( b );   //输出变量b的值15
  System.out.println(“b”); //输出b，双引号中的原样输出
  a = a+10; //取出a的值5，加10后，再赋值给a-----在a本身基础之上增10
  System.out.println( a );  //15
  ```

- 变量的操作必须与数据类型匹配

  ```java
  int a = 3.14;//编译错误，数据类型不匹配
  ```

- 变量在使用之前必须声明并初始化

  ```java
  System.out.println( m );  //编译错误，变量m未声明
  int m;
  System.out.println( m ); //编译错误，变量m为初始化
  ```

### 命名

- 只能包含字母、数字、_和$符，并且不能以数字开头
- 严格区分大小写
- 不能使用关键字
- 允许中文命名，但不建议，建议英文的见名知意、驼峰命名法

### 成员变量和局部变量是可以同名的

- 用的时候采取就近原则
- 结论: 当成员变量与局部变量同名时，this不能省略

---

## 基本数据类型(8种)

- byte
- short
- int
  - 整型，4个字节，-21个多亿到21个多亿
  - 整数直接量默认为int类型，但不能超范围，若超范围则发生编译错误
  - 两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入)
  - 整数运算时若超范围，会发生溢出(溢出不是个错误，但是需要避免)
- long
  - 长整型，8个字节，很大很大很大
  - 长整型直接量需要在数字后加`L`或`l`
  - 运算时若有可能溢出，建议在第一个数字后加L
- float
- double
  - 浮点型，8个字节
  - 浮点数直接量默认为double类型，若想表示float需要在数字后加F或f
  - double和float型数据在运算时，有可能发生舍入误差(精确场合不能使用)
- boolean
  - 布尔型，1个字节
  - 只能赋值为true或false
- char
  - 字符型，2个字节
  - 采用的是Unicode字符集编码格式，每个字符对应一个码(0到65535之间)
    - 表现的形式是字符char本质上是码int(ASCII码:`'a'-97` `'A'-65` `'0'-48`)
  - 字符型直接量必须放在单引号中，有且仅有一个
  - 特殊字符需通过`\`来转译

### 类型间转换

- 数据类型从小到大依次为
  - byte<short<int<long<flat<double
- 两种方式
  - 自动/隐式类型转换:小类型到大类型
  - 强制类型转换:大类型到小类型
    - 语法:(要转换成为的数据类型)变量
    - 强转有可能溢出或丢失精度
- 两点规则
  - 整数直接量可以直接赋值给byte,short,char，但不能超出范围
  - byte, short,char型数据参与运算时，系统先一律将其转换为int再运算

---

## 运算符

### 算术运算符

- `+`,`-`,`*`,`/`,`%`,`++`,`--`

### 关系运算符

- `>`,`<`,`>=`,`<=`,`==`,`!=`

### 逻辑运算符

- `&&`,`||`,`!`

### 赋值运算符

- `=`,`+=`,`-=`,`*=`,`/=`,`%=`

### 字符串连接运算符

- `+`

### 条件/三目运算符

- `boolean?数1:数2`

---

## 任何复杂的程序逻辑都可以通过三种结构来实现

### 顺序结构

- 从上往下逐行执行，每句必走

### 分支结构

- 有条件的执行某语句，并非每句必走

#### if结构

- 1条路

#### if...else结构

- 2条路

#### if...else if结构

- 多条路

#### switch...case结构

- 多条路
- 优点
  - 效率高，结构清晰
- 缺点
  - 整数，相等

### 循环结构

- 反复多次执行一段相同或相似的代码

#### 循环三要素

- 循环变量的初始化
- 循环的条件(以循环变量为基础)
- 循环变量的改变(向着循环的结束变)
  - 循环变量:在整个循环过程中所反复改变的那个数

#### while结构

- 先判断后执行，有可能一次都不执行
- 与次数无关

#### do...while结构

- 先执行后判断，至少执行一次
- 与次数无关
- 要素1与要素3相同时，首选do...while

#### for结构

- 应用率最高、与次数相关的

#### break

- 跳出循环

#### continue

- 跳过此次循环进入下一次循环

#### 三种循环结构的选择规则

- 先看是否与次数相关:
  - 若与次数相关，直接上for
  - 若与次数无关，再看要素1与要素3是否相同
    - 若相同--------------直接上do..while
    - 若不同--------------直接上while

#### 嵌套循环

- 循环中套循环，一般多行多列时使用，外层控制行，内层控制列

- 执行过程:
  -  外层循环走一次
  - 内层循环走所有次

- 建议: 嵌套层数越少越好，能用一层就不用两层，能用两层就不用三层，若业务必须通过三层以上的循环来解决，说明设计有问题

- break只能跳出一层循环

---

## 输出乘法表

```java
public static void main(String[] args) {
        for(int i=9;i>0;i--) {
            for(int j=1,k=10-i;j<=i;j++,k++) {
                System.out.print(j+"×"+k+"="+k*j+"\t");// \t: 水平制表位，固定占8位
            }
            System.out.println();
            }
        }
```

---

## 数组

- 是一种数据类型(引用类型)
- 相同数据类型元素的集合

### 数组的定义

- `int[] arr = new int[10];`声明整型数组arr包含10个元素，每个元素都是int型，默认值为0

### 数组的初始化

```java
int[ ] arr = new int[3]; //0,0,0
int[ ] arr = {1,4,7}; //1,4,7
int[ ] arr = new int[ ]{1,4,7}; //1,4,7
int[ ] arr;
//arr = {1,4,7}; //编译错误，此方式只能声明同时初始化
arr = new int[ ]{1,4,7}; //正确
```

### 数组的访问

- 通过(数组名.length)可以获取数组的长度(元素的个数)

  ```java
  int[ ] arr = new int[3];
  System.out.println(arr.length); //3
  ```

- 通过下标/索引来访问数组中的元素，下标从0开始，最大到(数组的长度-1)

  ```java
  int[ ] arr = new int[3];
  arr[0] = 100; //给第一个元素赋值为100
  arr[1] = 200; //给第二个元素赋值为200
  arr[2] = 300; //给第三个元素赋值为300
  //arr[3] = 400; //数组下标越界异常
  System.out.println(arr[arr.length-1]); //输出最后一个元素的值
  ```

### 数组的遍历

- 从头到尾

  ```java
  int[ ] arr = new int[10];
  for(int i=0;i<arr.length;i++){
    //arr[i]:表示arr中的每一个元素
    arr[i] = 100;  //给每个元素赋值为100
    System.out.println(arr[i]); //输出每个元素的值
  }
  ```

### 数组的复制

```java
System.arraycopy(a,1,b,0,4);
```

```java
int[ ] b = Arrays.copyOf(a,6);
a = Arrays.copyOf(a,a.length+1);
```

### 数组的排序

- `Arrays.sort(arr);` //对arr升序排列

### 引用类型数组

```java
Student[ ] stus = new Student[3]; //创建Student数组对象
stus[0] = new Student(“zs”, 25, “LF”);  //创建Student对象
stus[1] = new Student(“ls”, 26, “JMS”);
stus[2] = new Student(“ww”, 28, “SD”);
System.out.println(stus[0].name); //输出第一个学生的名字
stus[1].age = 35; //给第二个学生的年龄赋值为35
stus[2].sayHi(); //第三个学生跟大家问好
```

```java
Student[] stus = new Student[]{
  new Student(“zs”, 25, “LF”),
  new Student(“ls”, 26, “JMS”),
  new Student(“ww”, 28, “SD”)
};
```



---

## 方法

- 函数、过程
- 封装一段特定的业务逻辑功能
- 尽可能的独立，一个方法只干一件事
- 方法可以被反复多次调用
- 减少代码重复、有利于代码的维护、有利于团队的协作

### 方法的定义(5要素)

```java
修饰词 返回值类型 方法名(参数列表){
  方法体
}
```

- 修饰词
  - public static
- 返回值类型
  - 方法可以有返回值，也可以没有返回值:
  - 无返回值:
    -  返回值类型写成void
  - 有返回值:
    -  返回值类型写成特定的数据类型(只要是数据类型都可以)
  - 方法执行完以后:
    - 若后期还需要用到方法中的某个数据---------有返回值
    - 若后期不再需要用到方法中的某个数据-------无返回值
- 方法名
  - 命名要符合变量的命名规则，见名知意
- 参数列表
  - 方法可以有参，也可以无参
  - 注意: 无参意味着数据都是写死的，而有参可以使方法更加灵活
- 方法体
  - 具体的业务逻辑功能实现代码

### 方法的调用

- 无返回值: 
  - 方法名(有参传参);
- 有返回值:
  -  数据类型 变量 = 方法名(有参传参);

### return

- return 值; 
  - 结束方法的执行
  - 返回结果给调用方，用在有返回值的方法中

- return;
  - 结束方法的执行，用在无返回值的方法中

### 方法的签名

- 方法名+参数列表

### 方法的重载(overload)

- 发生在同一个类中，方法名相同，参数列表不同，方法体不同
- 遵循 “编译期绑定”，看参数/引用类型来绑定方法
- 编译器在编译时会根据方法的签名自动绑定调用的方法

### 方法的重写(override)

- 重新写、覆盖
  - 当派生类中觉得超类的行为不能满足派生类的需求时，需要重写
- 发生在父子类中，方法名相同，参数列表相同，方法体不同
- 遵循 “运行期绑定”，看对象类型来调用方法
- 规定
  - 重写方法被调用时，看对象的类型
- 重写要遵循 “两同两小一大”原则:虽然可以两同两小一大，但一般都是一模一样的
  - 两同:
    - 方法名相同
    - 参数列表相同
  - 两小:
    - 派生类方法的返回值类型小于或等于超类方法的
    - void时，必须相等
    - 基本类型时，必须相等
    - 引用类型时，小于或等于
  - 一大
    - 派生类方法抛出的异常小于或等于超类方法的
    - 派生类方法的访问权限大于或等于超类方法的

- 重写不是必须要发生的
  - 当派生类觉得超类的行为不能满足派生类的需求时，需要重写
  - 重写时表示必须要super.方法名()去调用超类方法的:
  - 当派生类的行为是在超类基础之上做操作时，才需要去super.方法名()调用超类方法

### 构造方法

- 给成员变量赋初始值
- 与类同名、没有返回值类型(连void都没有)
- 在创建(new)对象时被自动调用
- 若自己没有写构造方法，则编译器默认一个无参构造方法，若自己写了，则不再默认提供
- 构造方法可以重载

### this

- 指代当前对象，哪个对象调用方法它指的就是哪个对象
- 只能用在方法中，方法中访问成员变量之前默认有个this.

#### this的用法

- this.成员变量名
  - 访问成员变量(当成员变量与局部变量同名时，this不能省略)
- this.方法名()
  - 调用方法(一般都省略this)
- this()
  - 调用构造方法

---

## 面向对象

### 封装

- 类
  - 封装的是对象的属性和行为
- 方法
  - 封装的是具体的业务逻辑功能实现
- 访问控制修饰符
  - 封装的是具体的访问权限

### 类

- 现实生活中是由很多很多的对象组成的，基于对象抽出类

#### 什么是类

- 模子、类型/类别，代表一类个体
- 类是对象的模板，对象是类的具体的实例

#### 类中包含

- 成员变量
  - 对象所共有的属性/特征(数据)
- 方法
  - 对象所共有的行为(动作)

#### 如何创建类？如何创建对象？如何访问成员？

- 创建类: class 类名{ 成员变量、方法 }

- 创建对象: 类名 引用类型变量(引用) = new 类名();

- 访问成员: 引用.成员变量名 = 值;引用.方法名();

#### package

- 作用: 避免类名的冲突

- 类的全称: 包名.类名 包名有层次结构

- 同包中的类名不能同名，不同包中的类可以同名

- 建议: 包名所有字母都小写

#### import

- 同包中的类可以直接访问

- 不同包中的类不能直接访问，若想访问:
  - 先import声明类，再访问类，建议
  - 类的全程，太繁琐，不建议

### 访问控制修饰符

- 类的访问修饰符只能是public或默认的

- 类中成员的访问修饰符以下4种都可以

#### public

- 公开的，任何类
  - 行为(方法)公开化(public)

#### private

- 私有的，本类
  - 数据(成员变量)私有化(private)

#### protected

- 受保护的，本类、派生类、同包类
  - 超类的成员变量设计为受保护的

#### 默认的

- 什么也不写，本类、同包类
  - java不建议默认权限

### 成员变量

- 实例变量: 
  - 没有static修饰，属于对象的，存储在堆中，有几个对象就有几份，通过对象名点来访问
- 静态变量: 
  - 由static修饰，属于类的，存储在方法区中，只有一份，通过类名点来访问

### static

- 静态的

#### 静态变量

- 由static修饰
- 属于类，存储在方法区中，只有一份
- 常常通过类名点来访问
- 何时用: 
  - 所有对象所共享的数据(图片、音频、视频等)

#### 静态方法

- 由static修饰

- 属于类，存储在方法区中，只有一份

- 常常通过类名点来访问

- 静态方法没有隐式的this传递，所以静态方法中不能直接访问实例成员
- 何时用:
  -  方法的操作与对象无关

#### 静态块

- 由static修饰
- 属于类，在类被加载期间自动执行，因每个类只被加载一次，所以静态块只执行一次--发生的时期最早
- 何时用: 
  - 加载/初始化静态资源(图片、音频、视频等)

### final

- 最终的

#### 修饰变量

- 变量不能被改变

#### 修饰方法

- 方法不能被重写

#### 修饰类

- 类不能被继承

### static final常量

- 应用率高
- 必须声明同时初始化
- 通过类名点来访问，不能被改变
- 建议: 常量名所有字母都大写，多个单词用_分隔
- 编译器在编译时将常量直接替换为具体的值，效率高
- 何时用: 数据永远不变，并且经常使用

### 成员内部类

- 成员内部类: 应用率低
- 类中套类
  - 外面的类称为Outer外部类
  - 里面的称为Inner内部类
- 内部类通常只服务于外部类，对外不具备可见性
- 内部类对象通常只在外部类中创建
- 内部类中可以直接访问外部类的成员(包括私有的)
- 内部类中有个隐式的引用指向了创建它的外部类对象
- eg: 外部类名.this.

### 匿名内部类

- 匿名内部类: 简化代码
- 若想创建一个类(派生类)的对象，并且对象只被创建一次，此时该类不必命名，称为匿名内部类 
- 若想访问外面的变量，该变量必须是final的(JDK1.7(包括)以前必须的)
- 内部类有独立的.class吗？
  - 有

### 抽象

#### 抽象方法

- 由abstract修饰
- 只有方法的定义，没有具体的实现(连{ }都没有)

#### 抽象类

- 由abstract修饰

- 包含抽象方法的类必须是抽象类

- 抽象类不能被实例化(即: 不能被new对象)

- 抽象类是需要被继承的，派生类:

  - 重写抽象类中所有抽象方法
    - 变不完整为完整

  - 也声明为抽象类
    - 一般不这么做

#### 抽象类的意义

-  封装派生类所共有的属性和行为
  - 代码复用
- 为所有派生类提供统一的类型
  - 向上造型(代码复用)
- 可以包含抽象方法，为所有派生类提供统一的入口(造型之后通过超类引用能点出来)
- 派生类的具体实现不同，但入口是一致的(真正调用的还是派生类重写之后的

### 多态

- 多态的表现形式: 方法的重写

#### 意义

- 同一类型的引用，在指向不同的对象时，有不同的实现
  - 行为的多态:cut()、step()、getImage()... 
  - 说明: 所有抽象方法都是多态的
- 同一个对象，被造型为不同的类型时，有不同的功能        
  - 对象的多态:水、我... 
  - 说明: 所有对象都是多态的

#### 向上造型/自动类型转换

- 超类型的引用指向派生类的对象
- 能造型成为的类型有: 超类+所实现的接口
- 能点出来什么，看引用的类型

#### 强制类型转换

- 引用所指向的对象，就是该类型
- 引用所指向的对象，实现了该接口或继承了该类
- 强转时若不符合如上两种情况，则发生ClassCastException类型转换异常    
- 建议: 强转之前先通过instanceof来判断引用所指向的对象是否是该类型

### 继承

- 代码复用

- 通过extends来实现继承

- 超类/父类: 

  - 派生类所共有的属性和行为
  - 超类的构造方法不是被派生类继承的，而是被派生类通过super()来调用的

- 派生类/子类: 

  - 派生类所特有的属性和行为
  - 派生类继承的是超类的成员变量和方法

- 派生类继承超类后，派生类具有: 派生类的+超类的

- 继承要符合is a(是一个)的关系

- 单一继承

  - 一个超类可以有多个派生类，一个派生类只能有一个超类

- 继承具有传递性

-  Java规定: 

  - 在构造派生类之前必须先构造超类

  - 在派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法

  - 在派生类的构造方法中若调用了超类的构造方法，则不再默认提供

- 注意: super()调用超类构造方法必须位于派生类构造方法的第一行

### super

- 指代当前对象的超类对象

#### super的用法

- super.成员变量名
  - 访问超类的成员变量

- super.方法名()
  - 调用超类的方法

- super()
  - 调用超类的构造方法

### 接口

- 是一种引用数据类型
- 由interface定义
- 只能包含常量和抽象方法
- 接口不能被实例化(new对象)
- 接口是需要被实现/继承的，实现类/派生类:      
  - 必须重写所有抽象方法
- 一个类可以实现多个接口，用逗号分隔    
  - 若又继承又实现时，应先继承后实现
- 接口可以继承接口

#### 设计规则

- 将所有派生类所共有的属性和行为，抽到超类中，抽共性 
- 派生类的行为都一样，设计为普通方法
- 派生类的行为不一样，设计为抽象方法
- 将部分派生类所共有的属性和行为，抽到接口中  
- 接口是对继承单根性的扩展，实现多继承

### 做功能的套路

- 先写行为/方法:
  - 若为某个对象所特有的行为，就将方法设计在特定的类中
  - 若为所有对象所共有的行为，就将方法设计在超类中

---

## 内存

- 由JVM管理

### 堆

- 存储new出来的对象(包括实例变量)    

#### 垃圾

- 没有任何引用所指向的对象       

#### 垃圾回收器(GC)

- 不定时到内存中回收垃圾对象，回收过程是透明的(看不到的)， 
- 不一定发现垃圾就立刻回收，
- 通过调用System.gc()可以建议JVM尽快调度GC来回收    

#### 内存泄漏

- 不再使用的内存没有被及时的回收，严重的泄漏会导致系统的崩溃        
- 建议:对象不再使用时要及时的将引用设置为null    

#### 实例变量的生命周期

- 创建(new)对象时存储在堆中，对象被回收时一并被回收

### 栈

- 存储正在调用的方法中的所有局部变量(包括方法的参数)    
- 调用方法时会在栈中为该方法分配一块对应的栈帧，        
- 栈帧中存储方法中的局部变量(包括参数)， 
- 方法调用结束时，栈帧自动被清除，局部变量(包括参数)一并被清除    

#### 局部变量的生命周期

- 调用方法时存储在栈中，方法调用结束时与栈帧一并被清除

### 方法区

- 存储.class字节码文件(包括静态变量、方法) 
- 方法只有一份，通过this来区分具体的调用对象

