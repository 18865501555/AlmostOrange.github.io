## Java有没有goto语句

- goto是Java中的保留字，在目前版本的Java中没有使用
- 根据JamesGosling(Java之父)编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表
- 其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字
- 其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程 序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字

---

## &和&&的区别

- `&`运算符有两种用法
  - 按位与
  - 逻辑与
- `&&`运算符是短路与运算
  - 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是`true`整个表达式的值才是`true`
- `&&`之所以称为短路运算是因为如果`&&`左边的表达式的值是`false`，右边的表达式会被直接短路掉，不会进行运算
- 很多时候我们可能都需要用`&&`而不是`&`
  - 例如在验证用户登录时判定用户名不是`null`而且不是空字符串
    - 应当写为`username != null && !username.equals("")`
    - 二者的顺序不能交换，更不能用`&`运算符
    - 因为第一个条件如果不成立，根本不能进行字符串的`equals`比较，否则会产生`NullPointerException`异常
- 逻辑或运算符`|`和短路或运算符`||`的差别也是如此

---

## 在Java中，如何跳出当前的多重嵌套循环

- break;
  - 跳出整个循环体
- continue;
  - 跳出正在执行的一层循环，执行下一次循环

---

## 两个对象值相同`x.equals(y) == true`但却可有不同的hashCode，这句话对不对

- 不对
- 如果两个对象x和y满足x.equals(y) == true它们的hashCode应当相同

### Java对于equals方法和hashCode方法的规定

- 如果两个对象相同(equals方法返回true)，那么它们的hashCode值一定要相同
- 如果两个对象的hashCode相同，它们并不一定相同
- 如果违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降(对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降)

### equals方法

- equals方法必须满足
  - 自反性(x.equals(x)必须返回true)
  - 对称性(x.equals(y)返回true时，y.equals(x)也必须返回true)
  - 传递性(x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true)
  - 一致性(当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值)
  - 对于任何非null值的引用x，x.equals(null)必须返回false
- 实现高质量的equlas方法的诀窍
  - 使用==操作符检查参数是否为这个对象的引用
  - 使用instanceof操作符检查参数是否为正确的类型
  - 对类中的关键属性，检查参数传入对象的属性是否与之相匹配
  - 边写完equals方法后，问自己它是否满足对称性、传递性、一致性
  - 重写equals时总要重写hashCode
  - 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解

---

## 是否可以继承String

- `String`类是`final`类，不可以被继承
- 继承`String`本身就是一个错误的行为，对`String`类型最好的重用方式是关联关系`Has-A`和依赖关系`Use-A`而不是继承关系`Is-A`

---

## 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递

- 是值传递
- Java语言的方法调用只支持参数的值传递
- 当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用
- 对象的属性可以在被调用过程中被改变，但对对象引用的改变时不会影响到调用者的

---

## 重载(overload)和重写(override)的区别？重载的方法能否根据返回类型进行区分

- 方法的重载和重写都是实现多态的方式
- 区别在于
  - 重载实现的是编译时的多态性
  - 重写实现的是运行时的多态性
- 重载发生在一个类中，同名的方法如果有不同的参数列表(参数类型不同、参数个数不同或者二者都不同)则视为重载
- 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比如父类被重写方法更好访问，不能比父类被重写方法声明更多的异常
- 重载对返回类型没有特殊的要求

---

## 为什么函数不能根据返回类型来区分重载

- 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数

- 例如

  ```java
  float max(int a,int b);
  int max(int a,int b);
  ```

  当调用max(1,2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的

  在比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的

  ```java
  void f(){}
  int f(){}
  ```

  若编译器可根据上下文(语境)明确判断出含义，比如在int x=f()中，那么这样做完全没有问题。然后我们也可能调用一个方法，同时忽略返回值；通常把这称为"为他的副作用去调用一个方法"，因为我们关心的不是返回值，而是方法调用的其他效果，所以加入我们向下面这样调用方法:f();Java怎样判断f()的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在着一类问题，所以不能

- 函数的返回值只是作为函数运行之后的一个"状态"，它是保持方法的调用者与被调用者进行通信的关键

- 并不能作为某个方法的"标识"

---

## char型变量中能不能存储一个中文汉字，为什么

- char类型可以存储一个中文汉字
- 因为Java中使用的编码是Unicode(不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法)
- 一个char类型占2个字节(16bit)，所以放一个中文是没问题的

### Unicode

- 使用Unicode意味着字符在JVM内部和外部有不同的表现形式
- 在JVM内部都是Unicode
- 当这个字符被从JVM内部抓一到外部时(例如存入文件系统中)，需要进行编码转换
- 所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如
  - InputStreamReader
  - OutputStreamReader
  - 这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务

---

## 抽象类(abstract class)和接口(interface)有什么异同

- 不同点
  - 抽象类
    - 抽象类中可以定义构造器
    - 可以有抽象方法和具体方法
    - 接口中的成员全都是public的
    - 抽象类中可以定义成员变量
    - 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
    - 抽象类中可以包含静态方法
    - 一个类只能继承一个抽象类
  - 接口
    - 接口中不能定义构造器
    - 方法全部都是抽象方法
    - 抽象类中的成员可以是private、默认、protected、public
    - 接口中定义的成员变量实际上都是常量
    - 接口中不能有静态方法
    - 一个类可以实现多个接口
- 相同点
  - 不能够实例化
  - 可以将抽象类和接口类型作为引用类型
  - 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类

---

## 抽象的(abstract)方法是否可同时是静态的(static)，是否可同时是本地方法(native),是否可同时被synchronized

- 都不能
- 抽象方法需要子类重写，静态方法是无法被重写的，因此二者是矛盾的
- 本地方法是由本地代码实现的方法，而抽象方法是没有实现的，也是矛盾的
- synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的

---

## 阐述静态变量和实例变量的区别

- 静态变量
  - 是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝
- 实例变量
  - 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它
  - 静态变量可以实现让多个对象共享内存

---

## ==和equals的区别

- equals和==最大的区别是一个是方法一个是运算符
- equals方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址
  - ==
    - 如果比较的对象是基本数据类型，则比较的是数值是否相等
    - 如果比较的是引用数据类型，则比较的是对象的地址值是否相等
  - equals()
    - 用来比较方法两个对象的内容是否相等

---

## break和continue的区别

- break和continue都是用来控制循环的语句
  - break
    - 用于完全结束一个循环，跳出循环体执行循环后面的语句
  - continue
    - 用于跳过本次循环，执行下次循环

---

## String s = "Hello";s =s+"world";这两行代码执行后，原始的String对象中的内容到底变了没有

- 没有变
- 因为String被设计成不可变类，所以他的所有对象都是不可变对象
- 在这段代码中，s原先指向一个String对象，内容是"Hello"，然后我们对s进行了"+"操作，那么s所执行的那个对象是否发生了改变？
  - 没有变
- 这时，s不指向原来那个对象了，而指向了另一个String对象，内容为"Hello world!"原来那个对象还存在与内存之中，只是s这个引用变量不再指向它了

通过上面的说明，我们很容易得出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为String对象建立之后不能再改变,所以对于每一个不同的字符串，都需要一个String对象来表示。这是应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的转换十分容易，同时我们还可以知道吗如果要使用内容相同的字符串，不必每次都new一个String

例如我们要在一个构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值应该这样做

```java
private String s;
...
s = "Initial Value";
...
```

而不是

```java
s = new String("Intital Value");
```

后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就是说，多次调用上面的狗仔起创建多个对象，它们的String类型属性s都指向同一个对象

上面的结论还基于这样一个事实

- 对于字符串常量，如果内容相同，Java认为它们代表同一个String对象
- 而用关键字new调用的构造器,总是会创建一个新的对象，无论内容是否相同
- 至于为什么要把String类设计成不可变类，是它的用途决定的
- 其实不只是String，很多Java标准类库中的类都是不可变的
- 在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现
- 不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题
- 当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题
- 所以Java标准类库还提供了一个可变版本，即StringBuffer

