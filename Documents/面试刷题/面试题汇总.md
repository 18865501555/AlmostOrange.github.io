
## 集合相关

### `Collection`和`Collections`的区别

- `Collection`
  - 是`java.util`下的一个**接口**
  - 是各种集合结构的**父接口**
  - 继承与他的接口主要有`Set`和`List`
- `Collections`
  - 是`java.util`下的一个**类**
  - 包含有各种有关集合操作的**静态**方法
  - 实现对各种集合的搜索、排序、线程安全化等操作

### 说出`ArrayList.Vector`,`LinkedList`的存储性能和特性

- `ArrayList`
  - 使用`数组`方式存储数据
  - 此数组元素数大于实际存储的数据以便增加和插入元素
  - 允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢
- `Vector`
  - 使用`数组`方式村粗数据
  - 使用`synchronized`方法(线程安全)，通常性能上较`ArrayList`差
- `LinkedList`
  - 使用`双项链表`实现存储
  - 按序号索引数据需要进行前向或后向遍历
  - 插入数据时只需要记录本项的前后项即可
  - 插入速度较快

### 你所知道的集合类有哪些？主要方法？

- 最常用的集合类是`List`和`Map`
- `List`
  - 具体实现包括`ArrayList`和`Vector`
  - 它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表
  - `List`适用于按数值索引访问元素的情形
- `Map`
  - 提供了一个更通用的元素存储方法
  - `Map`集合类用于存储元素对(称作"键"和"值")
  - 每个键映射到一个值

### ArrayList 和 LinkedList 有什么区别

- ArrayList 是实现了基于动态数组的数据结构
  - 所以相对比对于查询数据，速度会比较快
- LinkedList 基于链表的数据结构
  - 所以相对比对于数据增加或删除速度会比较快

---

## 线程相关

### 线程的基本概念、线程的基本状态以及状态之间的关系

- 线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身
- `Java`中的线程有四种状态
  - 运行
  - 就绪
  - 挂起
  - 结束

### 启动一个线程时用`run()`还是`start()`

- 启动一个线程时调用`start()`方法
  - 使线程所代表的虚拟处理机处于可运行状态
  - 可以由`JVM`调度并执行
  - 并不意味着线程会立即运行
- run()方法可以产生必须退出的标志来停止一个线程

### 请说出你所知道的线程同步的方法

- `wait()`
  - 使一个线程处于等待状态，并且释放所持有的对象的`lock`
- `sleep()`
  - 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉`InterruptedException`异常
- `notify()`
  - 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由`JVM`确定唤醒哪个线程，而且不是按优先级
- `Allnotity()`
  - 唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争

### 多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？

- 多线程有两种实现方法
  - 继承`Thread`类
  - 实现`Runnable`接口
- 同步的实现方法有两种
  - `synchronized`
  - `wait`与`notify`

### 线程的基本概念、线程的基本状态以及状态之间的关系

- 新建`Born`
  - 新建的线程处于新建状态
- 就绪`Ready`
  - 在创建线程后，它将处于就绪状态，等待`start()`方法被调用
- 运行`Running`
  - 线程在开始执行时进入运行状态
- 睡眠`Sleeping`
  - 线程的执行可通过使用`sleep()`方法来暂时终止
  - 在睡眠后，线程将进入就绪状态
- 等待`Waiting`
  - 如果调用了`wait()`方法，线程将处于等待状态
  - 用于在两个或多个线程并发运行时
- 挂起`Suspended`
  - 在临时停止或中断线程的执行时，线程就处于挂起状态
- 恢复`Resume`
  - 在挂起的线程被恢复执行时，可以说它已被恢复
- 阻塞`Blocked`
  - 在线程等待一个事件时(例如输入/输出操作)，就称其处于阻塞状态
- 死亡`Dead`
  - 在`run()`方法已完成执行或其`stop()`方法被调用之后，线程就处于死亡状态

### 线程的同步、如何实现线程的同步

- 当两个或多个线程同时访问同一个变量，并且一个线程需要修改这个变量，就要用到线程同步
  - 在`Java`中，同步时通过`synchronized`关键字来定义的
  - 若是想同步化某程序段，可以使用`synchronize(object){}`方法，其中`{}`内的程序语句被同步化

### 用`Java`怎样实现多线程？线程有哪些状态？

- `Java`中实现多线程的方法有两种
  - 继承`java.lang`包中的`Thread`类
  - 用户自己的类实现`Runnable`接口
- 初始状态、就绪状态、阻塞状态、运行状态、死亡状态

### `sleep()`和`wait()`有什么区别

- `sleep()`方法

  - 是使线程停止一段时间的方法
  - 在`sleep`时间间隔期满后，线程不一定理机恢复执行，因为其他线程可能正在运行而且没有被调度为放弃执行
  - 是`Thread`类的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时候会自动恢复。
  - 调用`sleep`不会释放对象锁

- `wait()`方法

  - 是线程交互时，如果线程对一个同步对象发出一个`wait()`调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。
- 是`Object`类的方法，对此对象调用`wait`方法导致本线程放弃对象锁，进入等待次对象的等待锁定池，只有针对此对象发出`notify`方法(或`notifyAll`)后本线程才进入对象锁定池准备获得对象锁进入运行状态。
  

### 当一个线程进入一个对象的一个`synchronized`方法后，其他线程是否可以进入此对象的其他方法？

- 不可以，一个对象的一个`synchronized`方法只能由一个线程访问。

### 简述`synchronized`和`java.util.concurrent.locks.Lock`的异同

- 主要相同点
  - `Lock`能完成`synchronized`所实现的所有功能
- 主要不同点
  - `Lock`有比`synchronized`更精确的线程语义和更好的性能
  - `synchronized`会自动释放锁，而`Lock`一定要求程序员手工释放，并且必须在`finally`从句中释放

### Lock 与 Synchronized 的区别

- synchronized 和 lock 的用法区别用法上的区别：
  - synchronized：在需要同步的对象中加入此控制
- synchronized 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。
- lock：需要显示指定起始位置和终止位置。
   - 一般使用 ReentrantLock 类做为锁,多个线程中必须要使用一个 ReentrantLock 类做为对象才能保证锁的生效。
   - 且在加锁和解锁处需要通过 lock()和 unlock()显示指出。
   - 一般会在 finally 块中写 unlock()以防死锁。

- 加锁的机制的区别
  - synchronized：采用悲观锁
  - lock:采用乐观锁

- 性能上的区别：
  - 由于锁机制的区别，所以在线程竞争资源激烈的时候，
  - synchronized 在效率上一定程度低于 lock

---

## 异常相关



### `error`和`exception`有什么区别

- `error`
  - 表示恢复不是不可能但很困难的情况下的一种严重问题
  - 比如内存溢出，不可能指望程序能处理这样的情况
- `exception`
  - 表示一种设计或实现问题
  - 比如如果程序运行正常，从不会发生的情况

### 运行时异常与一般异常有何异同

- 异常表示程序运行过程中可能出现的非正常状态
  - `运行时异常`
    - 表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误
- `Java`编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常

### `Java`中的异常处理机制的简单原理和应用

- 当`Java`程序违反了`Java`的语义规则时，`Java`虚拟机就会将发生的错误表示为一个异常。
- 违反语义规则包括两种情况
  - `Java`类库内置的语义检查
    - 例如数组下标越界，会引发`IndexOutOfBoundsException`
    - 访问`null`的对象时会引发`NullPointerException`
  - `Java`允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择何时用`throw`关键字引发异常
- 所有的异常都是`java.lang.Thowable`的子类。

### 给一个你最常见到的`runtime exception`

| 名称                              | 翻译               | 解释                                                         |
| --------------------------------- | ------------------ | ------------------------------------------------------------ |
| `ArithmeticException`             | 算术异常           | 当出现异常的运算条件时，抛出此异常                           |
| `ArrayStoreException`             | 阵列存储异常       | 试图将错误类型的对象存储到一个对象数组时抛出的异常。         |
| `BufferOverflowException`         | 缓冲区溢出异常     | 相对*放置*操作达到目标缓冲区的限制时引发的未经检查的异常     |
| `BufferUnderflowException`        | 缓冲区溢出异常     | 相对的`get`操作达到源缓冲区的限制时引发的未经检查的异常      |
| `CannotRedoException`             | 不能重做异常       | 在告知`redo()`和不告知`UndoableEdit`时抛出                   |
| `CannotUndoException`             |                    | 在告知`undo()`和不告知`UndoableEdit`时抛出                   |
| `ClassCastException`              |                    | 抛出该异常以指示代码已尝试将对象强制转换为不是实例的子类     |
| `CMMException`                    | `CMM`异常          | 如果本机`CMM`返回错误，则抛出此异常                          |
| `ConcurrentModificationException` | 并发修改异常       | 当不允许对对象进行并发修改的方法被检测到时，可能会引发此异常 |
| `DOMException`                    |                    | `DOM`操作仅在“异常”情况下（即，由于逻辑原因，数据丢失或实现变得不稳定）而无法执行操作时才会引发异常 |
| `EmptyStackException`             | 空栈异常           | 由`Stack`类中的方法抛出以指示堆栈为空                        |
| `IllegalArgumentException`        |                    | 被抛出以指示方法已传递了非法或不适当的参数                   |
| `IllegalMonitorStateException`    |                    | 抛出该异常指示线程试图在对象的监视器上等待，或者通知其他线程在对象监视器上等待而没有拥有指定的监视器 |
| `IllegalPathStateException`       |                    | 如果在路径上执行的操作与正在执行的特定操作相比处于非法状态，例如在没有初始`moveto`的情况下将一个路径段追加到`GeneralPath`上，就会抛出一个异常。 |
| `IllegalStateException`           |                    | 标志着一个方法在非法或不适当的时间被调用。换句话说，`Java`环境或`Java`应用程序不在请求操作的适当状态 |
| `ImagingOpException`              | 成像`Op`异常       | 如果一个`BufferedImageOp`或`RasterOp`滤镜方法不能处理图像，则会抛出`ImagingOpException`。 |
| `IndexOutOfBoundsException`       | 数组下标越界异常   | 表示某种索引（例如数组，字符串或向量）的索引超出范围         |
| `MissingResourceException`        | 缺失资源异常       | 表示资源丢失                                                 |
| `NegativeArraySizeException`      | 负数组尺寸异常     | 如果应用程序尝试创建负大小的数组，则抛出该异常               |
| `NoSuchElementException`          |                    | 被各种访问器方法抛出以指示所请求的元素不存在                 |
| `NullPointerException`            | 空指针异常         | 当应用程序试图在需要对象的情况下使用`null`时抛出。这些情况包括<br/>调用`null`对象的实例方法。<br/>访问或修改一个`null`对象的字段。<br/>把`null`的长度当作一个数组。<br/>像访问数组一样访问或修改空对象的槽。<br/>将空值当作一个可抛出的值来抛出。<br/>应用程序应该抛出该类的实例，以表明对null对象的其他非法使用。`NullPointerException`对象可以由虚拟机构造，就像抑制被禁用和/或堆栈跟踪不可写一样。 |
| `ProfileDataException`            | 配置文件数据异常   | 当访问或处理`ICC_Profile`对象时发生错误时，会抛出这个异常。  |
| `ProviderException`               | 提供者异常         | 提供者异常（如配置错误或不可恢复的内部错误）的运行时异常，它可以被`Providers`子类化，以抛出专门的、特定于提供者的运行时错误。 |
| `RasterFormatException`           | 栅格格式异常       | 如果`Raster`中存在无效的布局信息，则抛出`RasterFormatException`。 |
| `SecurityException`               | 安全异常           | 由安全管理器抛出以指示安全违规。                             |
| `SystemException`                 | 系统异常           | 所有`CORBA`标准异常的根类。这些异常可能作为任何`CORBA`操作调用的结果被抛出，也可能被许多标准`CORBA API`方法返回。标准异常包含一个小代码，允许更详细的规范，以及一个完成状态。这个类被子类化来生成每一个标准`ORB`异常集。`SystemException`扩展了`java.lang.RuntimeException`；因此`SystemException`异常都不需要在IDL接口中操作映射的`Java`方法的签名中声明。 |
| `UndeclaredThrowableException`    | 未声明的可丢弃异常 | 如果其调用处理程序的`invoke`方法调用抛出了一个检查异常（一个不可分配给 `RuntimeException` 或 `Error` 的 `Throwable`），该异常不可分配给在代理实例上调用并派发给调用处理程序的方法的 `throws` 子句中声明的任何异常类型，则由该方法调用抛出。<br/>`UndeclaredThrowableException`实例包含由调用处理程序抛出的未声明的检查异常，它可以通过`getUndeclaredThrowable`()方法来检索。`UndeclaredThrowableException`扩展了`RuntimeException`，所以它是一个包装了检查异常的未检查异常。<br/><br/>从1.4版本开始，这个异常已经被改造成符合通用的异常链机制。可以在构造时提供 "由调用处理程序抛出的未声明的检查异常"，并通过`getUndeclaredThrowable`()方法访问，现在被称为原因，可以通过`Throwable.getCause()`方法以及前述 "遗留方法 "访问。" |
| `UnmodifiableSetException`        |                    | 抛出表示由于该集合不可修改而无法执行请求的操作。             |
| `UnsupportedOperationException`   | 不支持的操作异常   | 抛出该异常以指示不支持请求的操作。                           |

---

## 数据库相关

### 说出数据链接池的工作机制是什么？

- `J2EE`服务器启动时会建立一定数量的池连接，并一致维持不少于此数目的池连接
- 客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其标记为忙。
- 如果当前没有空闲连接，池驱动程序就会新建一定数量的连接，新建连接的数量由配置参数决定。
- 当使用的池连接调用完成后，池驱动程序会将此连接标记为空闲，其他调用就可以使用这个连接。

### 动态查询如何实现？

- 将查询封装进存储过程中，通过调用存储过程实现动态调用

### 表的结构变化后，如果不需要修改程序，如何设计和实现查询？

- 表结构发生变化后，修改响应的存储过程即可在不修改程序的情况下实现查询

### 如何优化数据库，如何跳过数据库的性能？

- 优化数据库主要是优化查询语句
- 通过高性能的查询语句提高数据库的性能

### 设计数据库应注意哪些问题？

- 首先应尽量满足三范式的要求，在一定程度上打破三范式的要求以提高数据库的性能

### 表与表之间的关联关系

- 一对一
- 一对多
- 多对多

### 主键和外键的区别

- 主键在本表中时唯一的、不可为空的
- 外键可以重复可以为空
- 外键和另一张表的主键关联，不能创建对应表中不存在的外键

### `JDBC`调用数据库的基本步骤

- 导入必要的类
- 装入`JDBC`驱动程序
- 识别数据源
- 分配`Connection`对象，分配`Statement`对象
- 使用`Statement`执行查询
- 从返回的`ResultSet`对象中检索数据
- 关闭`ResultSet`,关闭`Statement`对象,关闭`Connection`对象

### 数据库隔离级别有哪些，各自的含义是什么，MySQL 默认的隔离级别是是什么。

- Serializable (串行化)：
  - 级别最高，可避免脏读、不可重复读、幻读的发生。
- Repeatable read (可重复读)：
  - 可避免脏读、不可重复读的发生。
- Read committed (读已提交)：
  - 可避免脏读的发生。
- Read uncommitted (读未提交)：
  - 最低级别，任何情况都无法保证。


---

## GC相关

### `GC`是什么？为什么要有`GC`？

- `GC`是垃圾收集器
- `Java`程序员不用担心内存管理，因为来及收集器会自动进行管理
- 要请求垃圾收集，可以调用下面方法之一:
  - `System.gc()`
  - `Runtime.geRuntime().gc();`

---

## JVM相关

### JVM 的内存结构

- PC Register
  - 寄存器
- JVM Stack
  - JVM 栈
- Heap
  - 堆
- MethodArea
  - 方法区
- RuntimeConstant Pool
  - 运行时常量池，方法区的一部分
- NativeMethod Stacks
  - 本地方法堆栈

---

## 框架相关

### JDBC和Mybatis的区别

- Mybatis是一种支持SQL的持久层框架，底层仍然是JDBC
- Mybatis相对于直接使用JDBC,代码大大简化,比如能够直接将ResultSet中的数据转换成所需要的Java bean对象等
- Mybatis对SQL统一放到配置文件中进行管理，不用讲SQL语句分散在各个Java类中，方便代码的维护
- JDBC代码相对繁琐但访问速度更快，比如使用JDBC批处理等方式效率比Mybatis要高

### 简述一下事务以及事务的特性

- 事务：
  - 事务时一系列操作组成的业务单元，该业务单元内的操作时不可分割的，
    - 要么所有操作都做，要么所有操作都不做
  - 事务具有4个特性(ACID)，缺一不可
    - 原子性:
      - 事务时不可分割的最小业务单元，事务哪的操作要么全部都做，要么全部都不做
    - 一致性:
      - 事务执行时，是从一个一致状态变成另一个一致状态
    - 隔离性:
      - 一个事务的执行，不受其他事务(进程)的干扰
    - 持久性:
      - 事务一旦提交，对数据库的改变时持久的

### 什么是事务传播

- 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播

### 简述Spring事务配置过程

- Spring提供了多种事务管理器，将事务的具体工作委托给底层的持久化机制来实现(一般是数据库)
- Spring为不同的事务提供了一致的编程模型
- 具体使用时，可以选择使用声明式或者编程式事务

### 介绍一下Spring的事务管理

- 事务就是对一系列的数据库操作(比如插入多条数据)进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作
- 开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能
- Spring提供了几个关于事务处理的类
  - TransactionDefinition事务属性定义
  - TranscationStatus代表了当前的事务，可以提交，回滚
  - PlatformTransactionManager这个是Spring提供的用于管理事务的基础接口

### 简述Spring中BeanFactory和ApplicationContext作用

- ApplicationContext是BeanFactory接口的子接口
- BeanFactory采用的是延迟加载，第一次getBean的时候才会初始化Bean
- ApplicationContext是对BeanFactory的扩展，提供了更多的功能
  - 国际化处理
  - 事件传递
  - Bean自动装配
  - 各种不同应用层的Context实现
- 开发中尽量使用ApplicationContext就可以了

### BeanFactory接口和ApplicationContext接口有什么区别

- ApplicationContext接口继承BeanFactory接口，Spring核心工厂是BeanFactory,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean，ApplicationContext是会在加载配置文件时初始化Bean
- ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和Bean自动装配以及各种不同应用层的Context实现
- 开发中基本都在使用ApplicationContext，web项目使用WebApplicationContext，很少用到BeanFactory

### Spring里面applicationContext.xml文件能不能改成其他文件名

- ContextLoaderListener是一个ServletContextListener，它在你的web应用启动的时候初始化
- 缺省的情况下，它会在WEB-INF/applicationContext.xml文件找Spring的配置
- 你可以通过定义一个<context-param>元素名字为"contextConfigLocation"来改变Spring配置文件的位置

### Spring框架的优点都有什么

- 简化编程
  - Spring对javaEE中的一些比较繁琐的API做了简化的封装，使用封装之后的API不仅代码更简洁，而且质量更高
- 解耦
  - 对象之间的依赖关系由容器来统一管理，降低了对象之间的耦合度，方便代码的维护，同时也实现了资源的统一调度和管理
- 支持面向切面编程AOP
  - 可以方便对程序添加通用的服务，比如事务、权限管理等
- 集成其他框架
  - 不发明重复的轮子，集成其他一些优秀框架，使开发者用统一的病情更加简洁的方式来使用这些框架
- 轻量
  - 可以依赖项目的实际要求，有选择的使用Spring框架的全部或者一部分

### 构造器注入和setter依赖注入，哪种方式更好

- 每种方式都有它的缺点和优点
- 构造器注入保证所有的注入都被初始化，但是setter注入提供更好的灵活性来设置可选依赖
- 如果使用XML来描述依赖，Setter注入的可读写会更强
- 经验法则是强制依赖使用构造器注入，可选依赖使用setter注入

### 依赖注入和工厂模式之间有什么不同

- 虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工厂模式更清晰
- 通过依赖注入，你的类就是POJO，它只知道依赖而不关心它们怎么获取
- 使用工厂模式，你的类需要通过工厂来获取

### 列出IOC的3中主要注入方式

- 构造方法注入
- setter属性注入
- 接口注入

简述Spring中常见的几种Advice注解

- @Before
  - 在方法执行前处理
- @AfterReturning
  - 在方法正常执行后处理
- @AfterThrowing
  - 在方法执行期间抛出异常时处理
- @After
  - 在方法执行前后无论是否有异常也处理
- @Around
  - 在方法前后进行处理

### 什么是Spring的AOP，AOP的工作原理是什么

- 面向切面编程简称AOP
- Spring AOP是使用动态代理在运行期间植入增强的功能代码
- Spring的一个关键的组件就是AOP，其中最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事务管理之上
- 允许用户实现自定义切面，用AOP来完善OOP的使用，可以把Spring AOP看作是对Spring的一种增强

### 什么是IOC/DI，实现原理是什么

- IOC
  - Inverse Of Control 反转控制的概念，指的是对象之间的依赖关系交由容器(第三方)来管理
- DI
  - Dependency Injection 依赖注入，指容器通过调用构造器或者set方法来简历对象之间的依赖关系

### 简述Spring中常用注解

- @Component
  - 标准一个普通的spring Bean类
- @Repository
  - 标注一个Dao组件类
- @Service
  - 标注一个业务逻辑组件类
- @Controller
  - 标注一个控制器组件类
- @Resource
  - 注入组件

### 简述SpringMVC的请求流程

- 用户发送请求至前段控制器DispatcherServlet
- DispatcherServlet收到请求调用HandlerMapping处理映射器
- 处理映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet
- DispatcherServlet痛殴HandlerAdapter处理器适配器调用处理器
- 执行处理器(Controller，也叫后端控制器)
- Controller执行完成返回ModelAndView
- HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
- DispatcherServlet将ModelAndView传给ViewReslover视图解析器
- ViewReslover解析后返回具体View
- DispatcherServlet对View进行渲染视图(即将模型数据填充至视图中)
- DispatcherServlet响应用户

### 简述什么是MVC

- MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码
- 将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑
- Model(模型)
  - 是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据
- View(视图)
  - 是应用程序中处理数据显示的部分，通常视图是一句模型数据创建的
- Controller(控制器)
  - 是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

### SpringMVC如何解决线程安全性问题

- SpringMVC中的Controller默认时单例的，因此有可能有多个请求访问同一个Controller实例，从而有可能产生线程安全问题
- 因此尽量避免在Controller中使用实例变量
- 使用ThreadLocal变量

### 简单的说一下Spring的声明周期

- 实例化BeanFactoryPostProcessor实现类
- 执行BeanFactoryPostProcessor的postProcessBeanFactory方法
- 实例化BeanPostProcessor实现类
- 实例化InstantiationAwareBeanPostProcessBeforeInstantiantion方法
- 执行Bean的构造器
- 执行InstantiationAwareBeanPostProcessor的postProcesspropertyValues方法
- 为Bean注入属性
- 调用BeanNameAware的setBeanName方法
- 调用BeanFactoryAware的setBeanFactory方法
- 执行BeanPostProcessor的postProcessBeforeInitialization方法
- 调用InitializingBean的afterPropertiesSet方法
- 调用的init-method属性指定的初始化方法
- 执行BeanPostProcessor的postProcessAfterInitialization方法
- 执行InstantiationAwareBeanPostProcessor的postProcessAfterInitialization方法
- 容器初始化成功，执行正常调用后，下面销毁容器
- 调用DiposibleBean的destroy方法
- 调用的destroy-method属性指定的初始化方法

### 解释一下Spring AOP里面的几个名词

- 切面(Aspect)
  - 一个关注点的模块化，这个关注点可能会横切多个对象
  - 事务管理是J2EE应用中一个关于横切关注点的很好的例子
  - 在Spring AOP中，切面可以使用通用类(基于模式的风格)或者在普通类中以@Aspect注解(@AspectJ风格)来实现
- 连接点(Joinpoint)
  - 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候
  - 在Spring AOP中，一个连接点总是代表一个方法的执行
  - 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以通知(Advice)的主题部分获得连接点信息
- 通知(Advice)
  - 在切面的某个特定的连接点(Joinpoint)上执行的动作
  - 通知有各种类型，其中包括"around""before"和"after"等通知
  - 通知的类型将在后面部分进行讨论
  - 许多AOP框架，包括Spring，都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链
- 切入点(Pointcut)
  - 匹配连接点(Joinpoint)的断言
  - 通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行(例如，当执行某个特定名称的方法时)
  - 切入点表达式如何和连接点匹配时AOP的核心
    - Spring缺省使用AspectJ切入点语法
- 引入(Introduction)
  - （也被称为内部类型声明（inter-type declaration））。
  - 声明额外的方法或者某个类型的字段。
  - Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。
  - 例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。
- 目标对象(Target Object)
  - 被一个或者多个切面（aspect）所通知（advise）的对象。
  - 也有人把它叫做 被通知（advised） 对象。 
  - 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。
- AOP代理(AOP proxy)
  - AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 
  - 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 
  - 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。
- 织入(Weaving)
  - 把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。
  - 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 
  - Spring和其他纯Java AOP框架一样，在运行时完成织入。

### SpringMVC如何实现文件上载步骤

- RFC1876规定了HTTP文件上载协议
- 客户端
  - form标签中使用属性ENCTYPE="multipart/form-data" METHOD=POST
  - 使用input type=file标签选择文件
- 服务器端
  - 导入commons-fileupload组件
- 配置文件上载处理器
  - 在控制器方法声明MultipartFile类型变量接收上载文件

### SpringMVC如何实现Excel文件下载

- 利用Apache POI API生成Excel
- 在控制器中设置ContentType 为Excel文件类型
- 在控制器中设置Content-Disposition设定下载文件名