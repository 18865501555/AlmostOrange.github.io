# 集合相关

### `Collection`和`Collections`的区别

- `Collection`
  - 是`java.util`下的一个**接口**
  - 是各种集合结构的**父接口**
  - 继承与他的接口主要有`Set`和`List`
- `Collections`
  - 是`java.util`下的一个**类**
  - 包含有各种有关集合操作的**静态**方法
  - 实现对各种集合的搜索、排序、线程安全化等操作

### 说出`ArrayList.Vector`,`LinkedList`的存储性能和特性

- `ArrayList`
  - 使用`数组`方式存储数据
  - 此数组元素数大于实际存储的数据以便增加和插入元素
  - 允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢
- `Vector`
  - 使用`数组`方式村粗数据
  - 使用`synchronized`方法(线程安全)，通常性能上较`ArrayList`差
- `LinkedList`
  - 使用`双项链表`实现存储
  - 按序号索引数据需要进行前向或后向遍历
  - 插入数据时只需要记录本项的前后项即可
  - 插入速度较快

## 你所知道的集合类有哪些？主要方法？

- 最常用的集合类是`List`和`Map`
- `List`
  - 具体实现包括`ArrayList`和`Vector`
  - 它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表
  - `List`适用于按数值索引访问元素的情形
- `Map`
  - 提供了一个更通用的元素存储方法
  - `Map`集合类用于存储元素对(称作"键"和"值")
  - 每个键映射到一个值

# 线程相关

## 线程的基本概念、线程的基本状态以及状态之间的关系

- 线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身
- `Java`中的线程有四种状态
  - 运行
  - 就绪
  - 挂起
  - 结束

## 启动一个线程时用`run()`还是`start()`

- 启动一个线程时调用`start()`方法
  - 使线程所代表的虚拟处理机处于可运行状态
  - 可以由`JVM`调度并执行
  - 并不意味着线程会立即运行
- run()方法可以产生必须退出的标志来停止一个线程

## 请说出你所知道的线程同步的方法

- `wait()`
  - 使一个线程处于等待状态，并且释放所持有的对象的`lock`
- `sleep()`
  - 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉`InterruptedException`异常
- `notify()`
  - 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由`JVM`确定唤醒哪个线程，而且不是按优先级
- `Allnotity()`
  - 唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争

## 多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么？

- 多线程有两种实现方法
  - 继承`Thread`类
  - 实现`Runnable`接口
- 同步的实现方法有两种
  - `synchronized`
  - `wait`与`notify`

## 线程的基本概念、线程的基本状态以及状态之间的关系

- 新建`Born`
  - 新建的线程处于新建状态
- 就绪`Ready`
  - 在创建线程后，它将处于就绪状态，等待`start()`方法被调用
- 运行`Running`
  - 线程在开始执行时进入运行状态
- 睡眠`Sleeping`
  - 线程的执行可通过使用`sleep()`方法来暂时终止
  - 在睡眠后，线程将进入就绪状态
- 等待`Waiting`
  - 如果调用了`wait()`方法，线程将处于等待状态
  - 用于在两个或多个线程并发运行时
- 挂起`Suspended`
  - 在临时停止或中断线程的执行时，线程就处于挂起状态
- 恢复`Resume`
  - 在挂起的线程被恢复执行时，可以说它已被恢复
- 阻塞`Blocked`
  - 在线程等待一个事件时(例如输入/输出操作)，就称其处于阻塞状态
- 死亡`Dead`
  - 在`run()`方法已完成执行或其`stop()`方法被调用之后，线程就处于死亡状态

## 线程的同步、如何实现线程的同步

- 当两个或多个线程同时访问同一个变量，并且一个线程需要修改这个变量，就要用到线程同步
  - 在`Java`中，同步时通过`synchronized`关键字来定义的
  - 若是想同步化某程序段，可以使用`synchronize(object){}`方法，其中`{}`内的程序语句被同步化

## 用`Java`怎样实现多线程？线程有哪些状态？

- `Java`中实现多线程的方法有两种
  - 继承`java.lang`包中的`Thread`类
  - 用户自己的类实现`Runnable`接口
- 初始状态、就绪状态、阻塞状态、运行状态、死亡状态

## `sleep()`和`wait()`有什么区别

- `sleep()`方法

  - 是使线程停止一段时间的方法
  - 在`sleep`时间间隔期满后，线程不一定理机恢复执行，因为其他线程可能正在运行而且没有被调度为放弃执行
  - 是`Thread`类的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时候会自动恢复。
  - 调用`sleep`不会释放对象锁

- `wait()`方法

  - 是线程交互时，如果线程对一个同步对象发出一个`wait()`调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。
- 是`Object`类的方法，对此对象调用`wait`方法导致本线程放弃对象锁，进入等待次对象的等待锁定池，只有针对此对象发出`notify`方法(或`notifyAll`)后本线程才进入对象锁定池准备获得对象锁进入运行状态。
  

## 当一个线程进入一个对象的一个`synchronized`方法后，其他线程是否可以进入此对象的其他方法？

- 不可以，一个对象的一个`synchronized`方法只能由一个线程访问。

## 简述`synchronized`和`java.util.concurrent.locks.Lock`的异同

- 主要相同点
  - `Lock`能完成`synchronized`所实现的所有功能
- 主要不同点
  - `Lock`有比`synchronized`更精确的线程语义和更好的性能
  - `synchronized`会自动释放锁，而`Lock`一定要求程序员手工释放，并且必须在`finally`从句中释放

# 异常相关



## `error`和`exception`有什么区别

- `error`
  - 表示恢复不是不可能但很困难的情况下的一种严重问题
  - 比如内存溢出，不可能指望程序能处理这样的情况
- `exception`
  - 表示一种设计或实现问题
  - 比如如果程序运行正常，从不会发生的情况

## 运行时异常与一般异常有何异同

- 异常表示程序运行过程中可能出现的非正常状态
  - `运行时异常`
    - 表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误
- `Java`编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常

## `Java`中的异常处理机制的简单原理和应用

- 当`Java`程序违反了`Java`的语义规则时，`Java`虚拟机就会将发生的错误表示为一个异常。
- 违反语义规则包括两种情况
  - `Java`类库内置的语义检查
    - 例如数组下标越界，会引发`IndexOutOfBoundsException`
    - 访问`null`的对象时会引发`NullPointerException`
  - `Java`允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择何时用`throw`关键字引发异常
- 所有的异常都是`java.lang.Thowable`的子类。

## 给一个你最常见到的`runtime exception`

| 名称                              | 翻译               | 解释                                                         |
| --------------------------------- | ------------------ | ------------------------------------------------------------ |
| `ArithmeticException`             | 算术异常           | 当出现异常的运算条件时，抛出此异常                           |
| `ArrayStoreException`             | 阵列存储异常       | 试图将错误类型的对象存储到一个对象数组时抛出的异常。         |
| `BufferOverflowException`         | 缓冲区溢出异常     | 相对*放置*操作达到目标缓冲区的限制时引发的未经检查的异常     |
| `BufferUnderflowException`        | 缓冲区溢出异常     | 相对的`get`操作达到源缓冲区的限制时引发的未经检查的异常      |
| `CannotRedoException`             | 不能重做异常       | 在告知`redo()`和不告知`UndoableEdit`时抛出                   |
| `CannotUndoException`             |                    | 在告知`undo()`和不告知`UndoableEdit`时抛出                   |
| `ClassCastException`              |                    | 抛出该异常以指示代码已尝试将对象强制转换为不是实例的子类     |
| `CMMException`                    | `CMM`异常          | 如果本机`CMM`返回错误，则抛出此异常                          |
| `ConcurrentModificationException` | 并发修改异常       | 当不允许对对象进行并发修改的方法被检测到时，可能会引发此异常 |
| `DOMException`                    |                    | `DOM`操作仅在“异常”情况下（即，由于逻辑原因，数据丢失或实现变得不稳定）而无法执行操作时才会引发异常 |
| `EmptyStackException`             | 空栈异常           | 由`Stack`类中的方法抛出以指示堆栈为空                        |
| `IllegalArgumentException`        |                    | 被抛出以指示方法已传递了非法或不适当的参数                   |
| `IllegalMonitorStateException`    |                    | 抛出该异常指示线程试图在对象的监视器上等待，或者通知其他线程在对象监视器上等待而没有拥有指定的监视器 |
| `IllegalPathStateException`       |                    | 如果在路径上执行的操作与正在执行的特定操作相比处于非法状态，例如在没有初始`moveto`的情况下将一个路径段追加到`GeneralPath`上，就会抛出一个异常。 |
| `IllegalStateException`           |                    | 标志着一个方法在非法或不适当的时间被调用。换句话说，`Java`环境或`Java`应用程序不在请求操作的适当状态 |
| `ImagingOpException`              | 成像`Op`异常       | 如果一个`BufferedImageOp`或`RasterOp`滤镜方法不能处理图像，则会抛出`ImagingOpException`。 |
| `IndexOutOfBoundsException`       | 数组下标越界异常   | 表示某种索引（例如数组，字符串或向量）的索引超出范围         |
| `MissingResourceException`        | 缺失资源异常       | 表示资源丢失                                                 |
| `NegativeArraySizeException`      | 负数组尺寸异常     | 如果应用程序尝试创建负大小的数组，则抛出该异常               |
| `NoSuchElementException`          |                    | 被各种访问器方法抛出以指示所请求的元素不存在                 |
| `NullPointerException`            | 空指针异常         | 当应用程序试图在需要对象的情况下使用`null`时抛出。这些情况包括<br/>调用`null`对象的实例方法。<br/>访问或修改一个`null`对象的字段。<br/>把`null`的长度当作一个数组。<br/>像访问数组一样访问或修改空对象的槽。<br/>将空值当作一个可抛出的值来抛出。<br/>应用程序应该抛出该类的实例，以表明对null对象的其他非法使用。`NullPointerException`对象可以由虚拟机构造，就像抑制被禁用和/或堆栈跟踪不可写一样。 |
| `ProfileDataException`            | 配置文件数据异常   | 当访问或处理`ICC_Profile`对象时发生错误时，会抛出这个异常。  |
| `ProviderException`               | 提供者异常         | 提供者异常（如配置错误或不可恢复的内部错误）的运行时异常，它可以被`Providers`子类化，以抛出专门的、特定于提供者的运行时错误。 |
| `RasterFormatException`           | 栅格格式异常       | 如果`Raster`中存在无效的布局信息，则抛出`RasterFormatException`。 |
| `SecurityException`               | 安全异常           | 由安全管理器抛出以指示安全违规。                             |
| `SystemException`                 | 系统异常           | 所有`CORBA`标准异常的根类。这些异常可能作为任何`CORBA`操作调用的结果被抛出，也可能被许多标准`CORBA API`方法返回。标准异常包含一个小代码，允许更详细的规范，以及一个完成状态。这个类被子类化来生成每一个标准`ORB`异常集。`SystemException`扩展了`java.lang.RuntimeException`；因此`SystemException`异常都不需要在IDL接口中操作映射的`Java`方法的签名中声明。 |
| `UndeclaredThrowableException`    | 未声明的可丢弃异常 | 如果其调用处理程序的`invoke`方法调用抛出了一个检查异常（一个不可分配给 `RuntimeException` 或 `Error` 的 `Throwable`），该异常不可分配给在代理实例上调用并派发给调用处理程序的方法的 `throws` 子句中声明的任何异常类型，则由该方法调用抛出。<br/>`UndeclaredThrowableException`实例包含由调用处理程序抛出的未声明的检查异常，它可以通过`getUndeclaredThrowable`()方法来检索。`UndeclaredThrowableException`扩展了`RuntimeException`，所以它是一个包装了检查异常的未检查异常。<br/><br/>从1.4版本开始，这个异常已经被改造成符合通用的异常链机制。可以在构造时提供 "由调用处理程序抛出的未声明的检查异常"，并通过`getUndeclaredThrowable`()方法访问，现在被称为原因，可以通过`Throwable.getCause()`方法以及前述 "遗留方法 "访问。" |
| `UnmodifiableSetException`        |                    | 抛出表示由于该集合不可修改而无法执行请求的操作。             |
| `UnsupportedOperationException`   | 不支持的操作异常   | 抛出该异常以指示不支持请求的操作。                           |

# 数据库相关

## 说出数据链接池的工作机制是什么？

- `J2EE`服务器启动时会建立一定数量的池连接，并一致维持不少于此数目的池连接
- 客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其标记为忙。
- 如果当前没有空闲连接，池驱动程序就会新建一定数量的连接，新建连接的数量由配置参数决定。
- 当使用的池连接调用完成后，池驱动程序会将此连接标记为空闲，其他调用就可以使用这个连接。

## 动态查询如何实现？

- 将查询封装进存储过程中，通过调用存储过程实现动态调用

## 表的结构变化后，如果不需要修改程序，如何设计和实现查询？

- 表结构发生变化后，修改响应的存储过程即可在不修改程序的情况下实现查询

## 如何优化数据库，如何跳过数据库的性能？

- 优化数据库主要是优化查询语句
- 通过高性能的查询语句提高数据库的性能

## 设计数据库应注意哪些问题？

- 首先应尽量满足三范式的要求，在一定程度上打破三范式的要求以提高数据库的性能

## 表与表之间的关联关系

- 一对一
- 一对多
- 多对多

## 主键和外键的区别

- 主键在本表中时唯一的、不可为空的
- 外键可以重复可以为空
- 外键和另一张表的主键关联，不能创建对应表中不存在的外键

## `JDBC`调用数据库的基本步骤

- 导入必要的类
- 装入`JDBC`驱动程序
- 识别数据源
- 分配`Connection`对象，分配`Statement`对象
- 使用`Statement`执行查询
- 从返回的`ResultSet`对象中检索数据
- 关闭`ResultSet`,关闭`Statement`对象,关闭`Connection`对象

# GC相关

## `GC`是什么？为什么要有`GC`？

- `GC`是垃圾收集器
- `Java`程序员不用担心内存管理，因为来及收集器会自动进行管理
- 要请求垃圾收集，可以调用下面方法之一:
  - `System.gc()`
  - `Runtime.geRuntime().gc();`