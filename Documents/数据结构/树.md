### 二叉树

#### 完全二叉树

- 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

- 若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。

#### 满二叉树

- 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。

- 除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。

#### 平衡二叉树(Self-balancing binary search tree)

- 又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

#### 二叉查找树(BST)

- 若任意节点的左子树不空，则左子树上所有结点的     值均小于它的根结点的值；
 - 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
 - 任意节点的左、右子树也分别为二叉查找树。
 - 没有键值相等的节点（no duplicate nodes）。

### 红黑树

#### 特点

- 每个节点非红即黑；
- 根节点总是黑色的；
- 每个叶子节点都是黑色的空节点（NIL节点）；
- 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

#### 应用

- TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。

#### 为什么要用红黑树

- 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

### b树

- 是n叉树，所有数据只在节点上出现一次，搜索可以在非叶子节点结束。
- 每个节点的最大子节点数是m，最小是m的一半 
- 如果新增数据时该节点上的子节点数量大于m，就要将该节点分成两个节点
- 每个节点下的子节点数都是原来的一半，这个过程叫页分裂

### b+树

- 在b树的基础上 对查找效率进行了优化
- 所有数据都挂在叶子节点
- 所有非叶子节点都是叶子节点的索引
- 在叶子节点处，各个叶子节点通过指针跟旁边的节点关联，即叶子节点就是存储的数据

### b*树

- 解决页分裂的问题
- 非叶子节点的兄弟节点之间也通过指针相连，构成链表
- 如果节点上的子节点满了，就将它的子节点挪一部分到旁边没满的兄弟节点上
- 避免了重新创建新的节点的过程

### LSM 树

- B+树最大的性能问题是会产生大量的随机IO
- 为了克服B+树的弱点，HBase引入了LSM树的概念
- 即Log-Structured Merge-Trees。